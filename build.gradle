/*
 * Copyright 2009-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.apache.tools.ant.filters.ReplaceTokens

//===========================================
// Basic
//===========================================

apply plugin: 'groovy'
apply plugin: 'idea'

defaultTasks 'clean', 'test', 'dist' // whole tasks

sourceCompatibility = 1.6
targetCompatibility = 1.6

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.fusesource.jansi:jansi:1.11'
    }
}

repositories {
    mavenCentral()
    mavenRepo name: "codehaus", url: "http://repository.codehaus.org"
    mavenRepo name: "codehaus-snapshots", url: "http://snapshots.repository.codehaus.org"
}

configurations {
    // dependencies for archives are picked at compile configuration
    compile.extendsFrom archives
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.1.6'
    compile 'commons-cli:commons-cli:1.2'
    archives 'net.java.dev.jna:jna:3.2.7'
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
}

def defaultEncoding = 'UTF-8'
tasks.withType(AbstractCompile) each { it.options.encoding = defaultEncoding }
tasks.withType(GroovyCompile) each { it.groovyOptions.encoding = defaultEncoding }

//===========================================
// Tasks
//===========================================

//----------------------------------
// copySpec

def nativeBinSpec = copySpec {
    from("$projectDir") {
        include "*.txt"
        include "*.md"
    }
    into('lib') {
        from configurations.archives
        from "$buildDir/libs"
    }
    into('bin') {
        fileMode = 0755
        from "$buildDir/natives/groovyclient"     // ignored if not exists
        from "$buildDir/natives/groovyclient.exe" // ignored if not exists
    }
    into('bin') { // scripts with filter
        fileMode = 0755
        from "$projectDir/src/main/ruby"
        from "$projectDir/src/main/sh", {
            rename 'groovyserver.sh', 'groovyserver'
        }
        from "$projectDir/src/main/bat"
        filter(ReplaceTokens, tokens: ["GROOVYSERV_VERSION": project.version])
    }
}

def platformIndependentBinSpec = copySpec {
    from("$projectDir") {
        include "*.txt"
        include "*.md"
    }
    into('lib') {
        from configurations.archives
        from "$buildDir/libs"
    }
    into('bin') { // scripts with filter
        fileMode = 0755
        from "$projectDir/src/main/ruby"
        from "$projectDir/src/main/sh", {
            rename 'groovyclient.sh', 'groovyclient'
            rename 'groovyserver.sh', 'groovyserver'
        }
        from "$projectDir/src/main/bat"
        filter(ReplaceTokens, tokens: ["GROOVYSERV_VERSION": project.version])
    }
}

def srcSpec = copySpec {
    from("$projectDir") {
        include "*.txt"
        include "*.md"
        include "settings.gradle"
        include "build.gradle"
        include "gradle.properties"
        include "Makefile"
    }
    into("src") {
        from "$projectDir/src"
    }
    into("contrib") {
        from "$projectDir/contrib"
    }
    from("$projectDir") {
        fileMode = 0755
        include "gradlew*"
    }
    into("gradle") {
        from "$projectDir/gradle"
    }
}

//----------------------------------
// Build

jar {
    baseName = project.name

    // appending the commit id as suffix to the jar file's name of SNAPSHOT
    if (project.version ==~ /.*SNAPSHOT/) {
        def commitId = "xxxxxx"
        try  {
            commitId = executeCommand('git', ['log', '--no-color', '--oneline', '-1', 'HEAD']).split()[0]
        } catch (e) {
            assert e.cause instanceof IOException
            assert e.cause.message.startsWith("Cannot run program")
            AnsiColor.printlnAsYellow "WARN: Not found command: git"
            AnsiColor.printlnAsYellow "WARN: use snapshot classifier: ${commitId}"
        }
        classifier = commitId
    }
}

compileGroovy {
    dependsOn 'copyGroovyIntoMain'

    // Groovy sources shouldn't be compiled in order to avoid a trouble
    // of unmatch of Java version between compile-time and runtime.
    // Compiled groovy classes are used only by unit tests.
    // Instead, groovy sources in jar under executables dir are used
    // for integration test.
    exclude "**/*.groovy"
}

task copyGroovyIntoMain(type: Copy) {
    into "$buildDir/classes/main"
    from "$projectDir/src/main/groovy"
    filter(ReplaceTokens, tokens: ["GROOVYSERV_VERSION": project.version])
}

task compileC << {
    AnsiColor.printlnAsCyan ">> Compiling C sources..."
    def options = ['-e', "GROOVYSERV_VERSION=${project.version}"]
    if (Boolean.valueOf(System.properties['debug'])) {
        options << 'DEBUG=true'
    }
    executeCommand('make', options)
}

task assemble(overwrite: true, dependsOn: ['jar', 'compileC'])

task executables(dependsOn: ['executablesNativeBin', 'executablesPlatformIndependentBin'])

task executablesNativeBin(type: Copy, dependsOn: ['assemble']) {
    destinationDir = file("$buildDir/executables/native")
    with nativeBinSpec
}

task executablesPlatformIndependentBin(type: Copy, dependsOn: ['assemble']) {
    destinationDir = file("$buildDir/executables/platformIndependent")
    with platformIndependentBinSpec
}

//----------------------------------
// Distribution

task dist(dependsOn: ['distNativeBin', 'distPlatformIndependentBin', 'distSrc'])

task distNativeBin(type: Zip, dependsOn: ['assemble']) {
    baseName = project.name
    classifier = getOsSuffix() + '-bin'
    into "$baseName-$version"
    with nativeBinSpec
}

task distPlatformIndependentBin(type: Zip) {
    baseName = project.name
    classifier = 'platform-independent-bin'
    into "$baseName-$version"
    with platformIndependentBinSpec
}

task distSrc(type: Zip) {
    baseName = project.name
    classifier = 'src'
    into "$baseName-$version"
    with srcSpec
}

//----------------------------------
// Test

task test(overwrite: true, dependsOn: ['unitTest', 'integrationTest'])

task unitTest(type: Test) {
    testReportDir = file("$buildDir/reports/unit")
    testResultsDir = file("$buildDir/test-results/unit")
    doFirst {
        systemProperty 'spock.configuration', file("${projectDir}/spock/unit.groovy")
    }
    afterTest { desc, result -> 
        AnsiColor.printlnAsTestResult """Executing test: (${desc.className}) "${desc.name}" => ${result.resultType}"""
    }
}

// integrationTest tasks
def integrationTestSpecs = [
    [id: 'Java'],
    [id: 'CUnix', targetOs: ["macosx", "linux"]],
    [id: 'CWin', extension: '.exe', targetOs: ["windowsxp", "windows7"]],
    [id: 'Ruby', extension: '.rb', invoker: 'ruby'],
    [id: 'Shell', asPlatformIndependent: true],
].collect { new IntegrationTestSpec(it) }
integrationTestSpecs.each { spec ->
    // generate dynamically
    task "${spec.taskName}"(type: Test, dependsOn: 'executables') {
        mustRunAfter "unitTest"

        onlyIf { spec.shouldRun() }

        def testId = "integration-${spec.id}"
        testReportDir = file("$buildDir/reports/${testId}")
        testResultsDir = file("$buildDir/test-results/${testId}")

        def type = (spec.asPlatformIndependent) ? "platformIndependent" : "native"
        def binDir = convertMixedPath(file("${buildDir}/executables/${type}/bin"))
        def clientExecutableExpression = "${spec.invoker ?: ''} ${binDir}/groovyclient${spec.extension}".trim()
        def serverExecutableExpression = "$binDir/groovyserver"

        doFirst {
            // Support for -Dtest.single
            if (System.properties['test.single']) {
                include "**/${System.properties['test.single']}.*"
            } else {
                systemProperty 'spock.configuration', "${projectDir}/spock/${testId}.groovy"
            }

            // prop for TestUtils
            systemProperties 'groovyserv.executable.client': clientExecutableExpression
            systemProperties 'groovyserv.executable.server': serverExecutableExpression

            startGroovyServer(serverExecutableExpression)
        }
        doLast {
            shutdownGroovyServer(serverExecutableExpression)
        }
        afterTest { desc, result -> 
            AnsiColor.printlnAsTestResult """Executing test: (${desc.className}) "${desc.name}" => ${result.resultType}"""
        }
    }
}
task integrationTest(dependsOn: ['executables', integrationTestSpecs*.taskName])

//------------------------
// Gradle wrapper

task wrapper(type: Wrapper) {
    gradleVersion = '1.6'
}

//------------------------
// Documents

task docs << {
    executeCommand 'git', ['checkout', 'docs']
    executeCommand 'make', ['clean', 'html']
    executeCommand 'git', ['checkout', 'gh-pages']
    copy {
        into "$projectDir"
        from "$projectDir/build/docs"
    }
}

//===========================================
// Helper
//===========================================

def startGroovyServer(groovyserverPath) {
    AnsiColor.printlnAsCyan ">> Starting groovyserver..."
    executeCommand("sh", ['-c', "${groovyserverPath} -r -v"])
}

def shutdownGroovyServer(groovyserverPath) {
    AnsiColor.printlnAsCyan ">> Shutting down groovyserver..."
    executeCommand("sh", ['-c', "${groovyserverPath} -k"])
}

def executeCommand(command, arguments) {
    AnsiColor.printlnAsCyan ">> Executing command..."
    AnsiColor.printlnAsCyan "\$ $command ${arguments.join(' ')}"
    new ByteArrayOutputStream().withStream { os ->
        def result = exec {
            executable = command
            args = arguments
            standardOutput = os
        }
        println os.toString()
        return os.toString()
    }
}

def convertMixedPath(File file) {
    file.canonicalPath.replaceAll('\\\\', '/')
}

def getOsSuffix() {
    def osName = System.properties['os.name'].replaceAll(' ', '').toLowerCase()
    def osArch = System.properties['os.arch']
    return "${osName}-${osArch}"
}

class IntegrationTestSpec {
    def id
    def extension = ''
    def invoker
    def asPlatformIndependent = false
    def targetOs = ["*"]

    def getTaskName() {
        "integrationTestFor" + id
    }

    def shouldRun() {
        targetOs.contains("*") || targetOs.contains(osName)
    }

    private getOsName() {
        System.properties['os.name'].replaceAll(' ', '').toLowerCase()
    }
}

import org.fusesource.jansi.AnsiConsole
import static org.fusesource.jansi.Ansi.*
import static org.fusesource.jansi.Ansi.Color.*
class AnsiColor {
    static {
        AnsiConsole.systemInstall()
    }

    static printlnAsCyan(text) {
        println(ansi().fg(CYAN).a(text).reset())
    }

    static printlnAsYellow(text) {
        println(ansi().fg(YELLOW).a(text).reset())
    }

    static printlnAsTestResult(text) {
        println ansi().render(text.replaceAll(/(SUCCESS)/, "@|green \$1|@").replaceAll(/(ERROR|FAILURE)/, "@|red \$1|@"))
    }
}

